# C 语言教程

- ## C 语言简介

  - #### 历史

    > C 语言最初是作为 Unix 系统的开发工具而发明的。
    >
    > 1969年，美国贝尔实验室的肯·汤普森（Ken Thompson）与丹尼斯·里奇（Dennis Ritchie）一起开发了 Unix 操作系统。Unix 是用汇编语言写的，无法移植到其他计算机，他们决定使用高级语言重写。但是，当时的高级语言无法满足他们的要求，汤普森就在 BCPL 语言的基础上发明了 B 语言。
    >
    > 1972年，丹尼斯·里奇和布莱恩·柯林汉（Brian Kernighan）又在 B 语言的基础上重新设计了一种新语言，这种新语言取代了 B 语言，所以称为 C 语言。
    >
    > 1973年，整个 Unix 系统都使用 C 语言重写。此后，这种语言开始快速流传，广泛用于各种操作系统和系统软件的开发。
    >
    > 1988年，美国国家标准协会（ANSI）正式将 C 语言标准化，标志着 C 语言开始稳定和规范化。
    >
    > 几十年后的今天，C 语言依然是最广泛使用、最流行的系统编程语言之一，Unix 和 Linux 系统现在还是使用 C 语言开发。

  - #### C 语言的特点

    > C 语言能够长盛不衰、广泛应用，主要原因是它有一些鲜明的特点。
    >
    > （1）低级语言
    >
    > C 语言能够直接操作硬件、管理内存、跟操作系统对话，这使得它是一种非常接近底层的语言，也就是低级语言，非常适合写需要跟硬件交互、有极高性能要求的程序。
    >
    > （2）可移植性
    >
    > C 语言的原始设计目的，是将 Unix 系统移植到其他计算机架构。这使得它从一开始就非常注重可移植性，C 程序可以相对简单地移植到各种硬件架构和操作系统。
    >
    > 除了计算机，C 语言现在还是嵌入式系统的首选编程语言，汽车、照相机、家用电器等设备的底层系统都是用 C 语言编程，这也是因为它良好的可移植性。
    >
    > （3）简单性
    >
    > C 语言的语法相对简单，语法规则不算太多，也几乎没有语法糖。一般来说，如果两个语法可以完成几乎相同的事情，C 语言就只会提供一种，这样大大减少了语言的复杂性。
    >
    > 而且，C 语言的语法都是基础语法，不提供高级的数据结构，比如 C 语言没有“类”（class），复杂的数据结构都需要自己构造。
    >
    > （4）灵活性
    >
    > C 语言对程序员的限制很少。它假设程序员知道自己在干嘛，不会限制你做各种危险的操作，你干什么都可以，后果也由自己负责。
    >
    > C 语言的哲学是“信任程序员，不要妨碍他们做事”。比如，它让程序员自己管理内存，不提供内存自动清理功能。另外，也不提供类型检查、数组的负索引检查、指针位置的检查等保护措施。
    >
    > 表面上看，这似乎很危险，但是对于高级程序员来说，却有了更大的编程自由。不过，这也使得 C 语言的 debug 不太容易。
    >
    > （5）总结
    >
    > 上面这些特点，使得 C 语言可以写出性能非常强、完全发挥硬件潜力的程序，而且 C 语言的编译器实现难度相对较低。但是另一方面，C 语言代码容易出错，一般程序员不容易写好。
    >
    > 此外，当代很多流行语言都是以 C 语言为基础，比如 C++、Java、C#、JavaScript 等等。学好 C 语言有助于对这些语言加深理解。

  - #### C 语言的版本

    > 历史上，C 语言有过多个版本。
    >
    > （1）K＆R C
    >
    > `K&R C`指的是 C 语言的原始版本。1978年，C 语言的发明者丹尼斯·里奇（Dennis Ritchie）和布莱恩·柯林汉（Brian Kernighan）合写了一本著名的教材《C 编程语言》（The C programming language）。由于 C 语言还没有成文的语法标准，这本书就成了公认标准，以两位作者的姓氏首字母作为版本简称“K&R C”。
    >
    > （2）ANSI C（又称 C89 或 C90）
    >
    > C 语言的原始版本非常简单，对很多情况的描述非常模糊，加上 C 语法依然在快速发展，要求将 C 语言标准化的呼声越来越高。
    >
    > 1989年，美国国家标准协会（ANSI）制定了一套 C 语言标准。1990年，国际标准化组织（ISO）通过了这个标准。它被称为“ANSI C”，也可以按照发布年份，称为“C89 或 C90”。
    >
    > （3）C95
    >
    > 1995年，美国国家标准协会对1989年的那个标准，进行了补充，加入多字节字符和宽字符的支持。这个版本称为 C95。
    >
    > （4）C99
    >
    > C 语言标准的第一次大型修订，发生在1999年，增加了许多语言特性，比如双斜杠（`//`）的注释语法。这个版本称为 C99，是目前最流行的 C 版本。
    >
    > （5）C11
    >
    > 2011年，标准化组织再一次对 C 语言进行修订，增加了 Unicode 和多线程的支持。这个版本称为 C11。
    >
    > （6）C17
    >
    > C11 标准在2017年进行了修补，但发布是在2018年。新版本只是解决了 C11 的一些缺陷，没有引入任何新功能。这个版本称为 C17。
    >
    > （7）C2x
    >
    > 标准化组织正在讨论 C 语言的下一个版本，据说可能会在2023年通过，到时就会称为 C23。

  - #### C 语言的编译

    > C 语言是一种编译型语言，源码都是文本文件，本身无法执行。必须通过编译器，生成二进制的可执行文件，才能执行。编译器将代码从文本翻译成二进制指令的过程，就称为编译阶段，又称为“编译时”（compile time），跟运行阶段（又称为“运行时”）相区分。
    >
    > 目前，最常见的 C 语言编译器是自由软件基金会推出的 GCC 编译器，它可以免费使用。本书也使用这个编译器。Linux 和 Mac 系统可以直接安装 GCC，Windows 系统可以安装 MinGW。但是，也可以不用这么麻烦，网上有在线编译器，能够直接在网页上模拟运行 C 代码，查看结果，下面就是两个这样的工具。
    >
    > - CodingGround: https://tutorialspoint.com/compile_c_online.php
    > - OnlineGDB: https://onlinegdb.com/online_c_compiler
    >
    > 本书的例子都使用 GCC 在命令行进行编译。

  - #### Hello World 示例

    > C 语言的源代码文件，通常以后缀名`.c`结尾。下面是一个简单的 C 程序`hello.c`。它就是一个普通的文本文件，任何文本编译器都能用来写。
    >
    > ```c
    > #include <stdio.h>
    > 
    > int main(void) {
    >      printf("Hello World\n");
    >      return 0;
    > }
    > ```
    >
    > 上面这个程序的唯一作用，就是在屏幕上面显示“Hello World”。
    >
    > 这里不讲解这些代码是什么意思，只是作为一个例子，让大家看看 C 代码应该怎么编译和运行。假设你已经安装好了 GCC 编译器，可以打开命令行，执行下面的命令。
    >
    > ```bash
    > $ gcc hello.c
    > ```
    >
    > 上面命令使用`gcc`编译器，将源文件`hello.c`编译成二进制代码。注意，`$`是命令行提示符，你真正需要输入的是`$`后面的部分。
    >
    > 运行这个命令以后，默认会在当前目录下生成一个编译产物文件`a.out`（assembler output 的缩写，Windows 平台为`a.exe`）。执行该文件，就会在屏幕上输出`Hello World`。
    >
    > ```bash
    > $ ./a.out
    > Hello World
    > ```
    >
    > GCC 的`-o`参数（output 的缩写）可以指定编译产物的文件名。
    >
    > ```bash
    > $ gcc -o hello hello.c
    > ```
    >
    > 上面命令的`-o hello`指定，编译产物的文件名为`hello`（取代默认的`a.out`）。编译后就会生成一个名叫`hello`的可执行文件，相当于为`a.out`指定了名称。执行该文件，也会得到同样的结果。
    >
    > ```bash
    > $ ./hello
    > Hello World
    > ```
    >
    > GCC 的`-std=`参数（standard 的缩写）还可以指定按照哪个 C 语言的标准进行编译。
    >
    > ```bash
    > $ gcc -std=c99 hello.c
    > ```
    >
    > 上面命令指定按照 C99 标准进行编译。
    >
    > 注意，`-std`后面需要用`=`连接参数，而不是像上面的`-o`一样用空格，并且`=`前后也不能有多余的空格。

- ## 基本语法

  - #### 语句

    > C 语言的代码由一行行语句（statement）组成。语句就是程序执行的一个操作命令。C 语言规定，语句必须使用分号结尾，除非有明确规定可以不写分号。
    >
    > ```c
    > int x = 1;
    > ```
    >
    > 上面就是一个变量声明语句，声明整数变量`x`，并且将值设为`1`。
    >
    > 多个语句可以写在一行。
    >
    > ```
    > int x; x = 1;
    > ```
    >
    > 上面示例是两个语句写在一行。所以，语句之间的换行符并不是必需的，只是为了方便阅读代码。
    >
    > 一个语句也可以写成多行，这时就要依靠分号判断语句在哪一行结束。
    >
    > ```
    > int x;
    > x
    > =
    > 1
    > ;
    > ```
    >
    > 上面示例中，第二个语句`x = 1;`被拆成了四行。编译器会自动忽略代码里面的换行。
    >
    > 单个分号也是有效语句，称为“空语句”，虽然毫无作用。
    >
    > ```
    > ;
    > ```

  - #### 表达式

    > C 语言的各种计算，主要通过表达式完成。表达式（expression）是一个计算式，用来获取值。
    >
    > ```
    > 1 + 2
    > ```
    >
    > 上面代码就是一个表达式，用来获取`1 + 2`这个算术计算的结果。
    >
    > 表达式加上分号，也可以成为语句，但是没有实际的作用。
    >
    > ```
    > 8;
    > 3 + 4;
    > ```
    >
    > 上面示例是两个表达式，加上分号以后成为语句。
    >
    > 表达式与语句的区别主要是两点：
    >
    > - 语句可以包含表达式，但是表达式本身不构成语句。
    > - 表达式都有返回值，语句不一定有。因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句（`int x = 1`）就没有返回值。

  - #### 语句块

    > C 语言允许多个语句使用一对大括号`{}`，组成一个块，也称为复合语句（compounded statement）。在语法上，语句块可以视为多个语句组成的一个复合语句。
    >
    > ```
    > {
    >   int x;
    >   x = 1;
    > }
    > ```
    >
    > 上面示例中，大括号形成了一个语句块。
    >
    > 大括号的结尾不需要添加分号。

  - #### 空格

    > C 语言里面的空格，主要用来帮助编译器区分语法单位。如果语法单位不用空格就能区分，空格就不是必须的，只是为了增加代码的可读性。
    >
    > ```
    > int x = 1;
    > // 等同于
    > int x=1;
    > ```
    >
    > 上面示例中，赋值号（`=`）前后有没有空格都可以，因为编译器这里不借助空格，就能区分语法单位。
    >
    > 语法单位之间的多个空格，等同于单个空格。
    >
    > ```
    > int    x =     1;
    > ```
    >
    > 上面示例中，各个语法单位之间的多个空格，跟单个空格的效果是一样的。
    >
    > 空格还用来表示缩进。多层级的代码有没有缩进，其实对于编译器来说并没有差别，没有缩进的代码也是完全可以运行的。强调代码缩进，只是为了增强代码可读性，便于区分代码块。
    >
    > 大多数 C 语言的风格要求是，下一级代码比上一级缩进4个空格。为了书写的紧凑，本书采用缩写两个空格。
    >
    > ```
    > // 缩进四个空格
    > if (x > 0)
    >     printf("positive\n");
    > 
    > // 缩进两个空格
    > if (x > 0)
    >   printf("positive\n");
    > ```
    >
    > 只包含空格的行被称为空白行，编译器会完全忽略该行。

  - #### 注释

    > 注释是对代码的说明，编译器会忽略注释，也就是说，注释对实际代码没有影响。
    >
    > C 语言的注释有两种表示方法。第一种方法是将注释放在`/*...*/`之间，内部可以分行。
    >
    > ```
    > /* 注释 */
    > 
    > /*
    >   这是一行注释
    > */
    > ```
    >
    > 这种注释可以插在行内。
    >
    > ```
    > int open(char* s /* file name */, int mode);
    > ```
    >
    > 上面示例中，`/* file name */`用来对函数参数进行说明，跟在它后面的代码依然会有效执行。
    >
    > 这种注释一定不能忘记写结束符号`*/`，否则很容易导致错误。
    >
    > ```
    > printf("a "); /* 注释一
    > printf("b ");
    > printf("c "); /* 注释二 */
    > printf("d ");
    > ```
    >
    > 上面示例的原意是，第一行和第三行代码的尾部，有两个注释。但是，第一行注释忘记写结束符号，导致注释一延续到第三行结束。
    >
    > 第二种写法是将注释放在双斜杠`//`后面，从双斜杠到行尾都属于注释。这种注释只能是单行，可以放在行首，也可以放在一行语句的结尾。这是 C99 标准新增的语法。
    >
    > ```
    > // 这是一行注释
    > 
    > int x = 1; // 这也是注释
    > ```
    >
    > 不管是哪一种注释，都不能放在双引号里面。双引号里面的注释符号，会成为字符串的一部分，解释为普通符号，失去注释作用。
    >
    > ```
    > printf("// hello /* world */ ");
    > ```
    >
    > 上面示例中，双引号里面的注释符号，都会被视为普通字符，没有注释作用。
    >
    > 编译时，注释会被替换成一个空格，所以`min/* space */Value`会变成`min Value`，而不是`minValue`。

  - #### `printf()`

    - ##### 基本用法

      > 本书的示例会大量用到`printf()`函数，这里先介绍一下这个函数。
      >
      > `printf()`的作用是将参数文本输出到屏幕。它名字里面的`f`代表`format`（格式化），表示可以定制输出文本的格式。
      >
      > ```
      > printf("Hello World");
      > ```
      >
      > 上面命令会在屏幕上输出一行文字“Hello World”。
      >
      > `printf()`不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。为了让光标移到下一行的开头，可以在输出文本的结尾，添加一个换行符`\n`。
      >
      > ```
      > printf("Hello World\n");
      > ```
      >
      > 如果文本内部有换行，也是通过插入换行符来实现。
      >
      > ```
      > printf("Hello\nWorld\n");
      > ```
      >
      > 上面示例先输出一个`Hello`，然后换行，在下一行开头输出`World`，然后又是一个换行。
      >
      > 上面示例也可以写成两个`printf()`，效果完全一样。
      >
      > ```
      > printf("Hello\n");
      > printf("World\n");
      > ```
      >
      > `printf()`是在标准库的头文件`stdio.h`定义的。使用这个函数之前，必须在源码文件头部引入这个头文件。
      >
      > ```
      > #include <stdio.h>
      > 
      > int main(void) {
      >   printf("Hello World\n");
      > }
      > ```
      >
      > 上面示例中，只有在源码头部加上`#include <stdio.h>`，才能使用`printf()`这个函数。`#include`指令的详细解释，请看《预处理器》一章。

    - ##### 占位符

      > `printf()`可以在输出文本中指定占位符。所谓“占位符”，就是这个位置可以用其他值代入。
      >
      > ```
      > // 输出 There are 3 apples
      > printf("There are %i apples\n", 3);
      > ```
      >
      > 上面示例中，`There are %i apples\n`是输出文本，里面的`%i`就是占位符，表示这个位置要用其他值来替换。占位符的第一个字符一律为百分号`%`，第二个字符表示占位符的类型，`%i`表示这里代入的值必须是一个整数。
      >
      > `printf()`的第二个参数就是替换占位符的值，上面的例子是整数`3`替换`%i`。执行后的输出结果就是`There are 3 apples`。
      >
      > 常用的占位符除了`%i`，还有`%s`表示代入的是字符串。
      >
      > ```
      > printf("%s will come tonight\n", "Jane");
      > ```
      >
      > 上面示例中，`%s`表示代入的是一个字符串，所以`printf()`的第二个参数就必须是字符串，这个例子是`Jane`。执行后的输出就是`Jane will come tonight`。
      >
      > 输出文本里面可以使用多个占位符。
      >
      > ```
      > printf("%s says it is %i o'clock\n", "Ben", 21);
      > ```
      >
      > 上面示例中，输出文本`%s says it is %i o'clock`有两个占位符，第一个是字符串占位符`%s`，第二个是整数占位符`%i`，分别对应`printf()`的第二个参数（`Ben`）和第三个参数（`21`）。执行后的输出就是`Ben says it is 21 o'clock`。
      >
      > `printf()`参数与占位符是一一对应关系，如果有`n`个占位符，`printf()`的参数就应该有`n + 1`个。如果参数个数少于对应的占位符，`printf()`可能会输出内存中的任意值。
      >
      > `printf()`的占位符有许多种类，与 C 语言的数据类型相对应。下面按照字母顺序，列出常用的占位符，方便查找，具体含义在后面章节介绍。
      >
      > - `%a`：十六进制浮点数，字母输出为小写。
      > - `%A`：十六进制浮点数，字母输出为大写。
      > - `%c`：字符。
      > - `%d`：十进制整数。
      > - `%e`：使用科学计数法的浮点数，指数部分的`e`为小写。
      > - `%E`：使用科学计数法的浮点数，指数部分的`E`为大写。
      > - `%i`：整数，基本等同于`%d`。
      > - `%f`：小数（包含`float`类型和`double`类型）。
      > - `%g`：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的`e`为小写。
      > - `%G`：等同于`%g`，唯一的区别是指数部分的`E`为大写。
      > - `%hd`：十进制 short int 类型。
      > - `%ho`：八进制 short int 类型。
      > - `%hx`：十六进制 short int 类型。
      > - `%hu`：unsigned short int 类型。
      > - `%ld`：十进制 long int 类型。
      > - `%lo`：八进制 long int 类型。
      > - `%lx`：十六进制 long int 类型。
      > - `%lu`：unsigned long int 类型。
      > - `%lld`：十进制 long long int 类型。
      > - `%llo`：八进制 long long int 类型。
      > - `%llx`：十六进制 long long int 类型。
      > - `%llu`：unsigned long long int 类型。
      > - `%Le`：科学计数法表示的 long double 类型浮点数。
      > - `%Lf`：long double 类型浮点数。
      > - `%n`：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。
      > - `%o`：八进制整数。
      > - `%p`：指针。
      > - `%s`：字符串。
      > - `%u`：无符号整数（unsigned int）。
      > - `%x`：十六进制整数。
      > - `%zd`：`size_t`类型。
      > - `%%`：输出一个百分号。

    - ##### 输出格式

      > `printf()`可以定制占位符的输出格式。
      >
      > （1）限定宽度
      >
      > `printf()`允许限定占位符的最小宽度。
      >
      > ```
      > printf("%5d\n", 123); // 输出为 "  123"
      > ```
      >
      > 上面示例中，`%5d`表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。
      >
      > 输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的`%`的后面插入一个`-`号。
      >
      > ```
      > printf("%-5d\n", 123); // 输出为 "123  "
      > ```
      >
      > 上面示例中，输出内容`123`的后面添加了空格。
      >
      > 对于小数，这个限定符会限制所有数字的最小显示宽度。
      >
      > ```
      > // 输出 "  123.450000"
      > printf("%12f\n", 123.45);
      > ```
      >
      > 上面示例中，`%12f`表示输出的浮点数最少要占据12位。由于小数的默认显示精度是小数点后6位，所以`123.45`输出结果的头部会添加2个空格。
      >
      > （2）总是显示正负号
      >
      > 默认情况下，`printf()`不对正数显示`+`号，只对负数显示`-`号。如果想让正数也输出`+`号，可以在占位符的`%`后面加一个`+`。
      >
      > ```
      > printf("%+d\n", 12); // 输出 +12
      > printf("%+d\n", -12); // 输出 -12
      > ```
      >
      > 上面示例中，`%+d`可以确保输出的数值，总是带有正负号。
      >
      > （3）限定小数位数
      >
      > 输出小数时，有时希望限定小数的位数。举例来说，希望小数点后面只保留两位，占位符可以写成`%.2f`。
      >
      > ```
      > // 输出 Number is 0.50
      > printf("Number is %.2f\n", 0.5);
      > ```
      >
      > 上面示例中，如果希望小数点后面输出3位（`0.500`），占位符就要写成`%.3f`。
      >
      > 这种写法可以与限定宽度占位符，结合使用。
      >
      > ```
      > // 输出为 "  0.50"
      > printf("%6.2f\n", 0.5);
      > ```
      >
      > 上面示例中，`%6.2f`表示输出字符串最小宽度为6，小数位数为2。所以，输出字符串的头部有两个空格。
      >
      > 最小宽度和小数位数这两个限定值，都可以用`*`代替，通过`printf()`的参数传入。
      >
      > ```
      > printf("%*.*f\n", 6, 2, 0.5);
      > 
      > // 等同于
      > printf("%6.2f\n", 0.5);
      > ```
      >
      > 上面示例中，`%*.*f`的两个星号通过`printf()`的两个参数`6`和`2`传入。
      >
      > （4）输出部分字符串
      >
      > `%s`占位符用来输出字符串，默认是全部输出。如果只想输出开头的部分，可以用`%.[m]s`指定输出的长度，其中`[m]`代表一个数字，表示所要输出的长度。
      >
      > ```
      > // 输出 hello
      > printf("%.5s\n", "hello world");
      > ```
      >
      > 上面示例中，占位符`%.5s`表示只输出字符串“hello world”的前5个字符，即“hello”。

  - #### 标准库，头文件

    > 程序需要用到的功能，不一定需要自己编写，C 语言可能已经自带了。程序员只要去调用这些自带的功能，就省得自己编写代码了。举例来说，`printf()`这个函数就是 C 语言自带的，只要去调用它，就能实现在屏幕上输出内容。
    >
    > C 语言自带的所有这些功能，统称为“标准库”（standard library），因为它们是写入标准的，到底包括哪些功能，应该怎么使用的，都是规定好的，这样才能保证代码的规范和可移植。
    >
    > 不同的功能定义在不同的文件里面，这些文件统称为“头文件”（header file）。如果系统自带某一个功能，就一定还会自带描述这个功能的头文件，比如`printf()`的头文件就是系统自带的`stdio.h`。头文件的后缀通常是`.h`。
    >
    > 如果要使用某个功能，就必须先加载对应的头文件，加载使用的是`#include`命令。这就是为什么使用`printf()`之前，必须先加载`stdio.h`的原因。
    >
    > ```
    > #include <stdio.h>
    > ```
    >
    > 注意，加载头文件的`#include`语句不需要分号结尾，详见《预处理器》一章。

- ## 变量

  > 变量（variable）可以理解成一块内存区域的名字。通过变量名，可以引用这块内存区域，获取里面存储的值。由于值可能发生变化，所以称为变量，否则就是常量了。

  - #### 变量名

    > 变量名在 C 语言里面属于标识符（identifier），命名有严格的规范。
    >
    > - 只能由字母（包括大写和小写）、数字和下划线（`_`）组成。
    > - 不能以数字开头。
    > - 长度不能超过63个字符。
    >
    > 下面是一些无效变量名的例子。
    >
    > ```
    > $zj
    > j**p
    > 2cat
    > Hot-tab
    > tax rate
    > don't
    > ```
    >
    > 上面示例中，每一行的变量名都是无效的。
    >
    > 变量名区分大小写，`star`、`Star`、`STAR`都是不同的变量。
    >
    > 并非所有的词都能用作变量名，有些词在 C 语言里面有特殊含义（比如`int`），另一些词是命令（比如`continue`），它们都称为关键字，不能用作变量名。另外，C 语言还保留了一些词，供未来使用，这些保留字也不能用作变量名。下面就是 C 语言主要的关键字和保留字。
    >
    > > auto, break, case, char, const, continue, default, do, double, else, enum, extern, float, for, goto, if, inline, int, long, register, restrict, return, short, signed, sizeof, static, struct, switch, typedef, union, unsigned, void, volatile, while
    >
    > 另外，两个下划线开头的变量名，以及一个下划线 + 大写英文字母开头的变量名，都是系统保留的，自己不应该起这样的变量名。

  - #### 变量的声明

    > C 语言的变量，必须先声明后使用。如果一个变量没有声明，就直接使用，会报错。
    >
    > 每个变量都有自己的类型（type）。声明变量时，必须把变量的类型告诉编译器。
    >
    > ```
    > int height;
    > ```
    >
    > 上面代码声明了变量`height`，并且指定类型为`int`（整数）。
    >
    > 如果几个变量具有相同类型，可以在同一行声明。
    >
    > ```
    > int height, width;
    > 
    > // 等同于
    > int height;
    > int width;
    > ```
    >
    > 注意，声明变量的语句必须以分号结尾。
    >
    > 一旦声明，变量的类型就不能在运行时修改。

  - #### 变量的赋值

    > C 语言会在变量声明时，就为它分配内存空间，但是不会清除内存里面原来的值。这导致声明变量以后，变量会是一个随机的值。所以，变量一定要赋值以后才能使用。
    >
    > 赋值操作通过赋值运算符（`=`）完成。
    >
    > ```
    > int num;
    > num = 42;
    > ```
    >
    > 上面示例中，第一行声明了一个整数变量`num`，第二行给这个变量赋值。
    >
    > 变量的值应该与类型一致，不应该赋予不是同一个类型的值，比如`num`的类型是整数，就不应该赋值为小数。虽然 C 语言会自动转换类型，但是应该避免赋值运算符两侧的类型不一致。
    >
    > 变量的声明和赋值，也可以写在一行。
    >
    > ```
    > int num = 42;
    > ```
    >
    > 多个相同类型变量的赋值，可以写在同一行。
    >
    > ```
    > int x = 1, y = 2;
    > ```
    >
    > 注意，赋值表达式有返回值，等于等号右边的值。
    >
    > ```
    > int x, y;
    > 
    > x = 1;
    > y = (x = 2 * x);
    > ```
    >
    > 上面代码中，变量`y`的值就是赋值表达式（`x = 2 * x`）的返回值`2`。
    >
    > 由于赋值表达式有返回值，所以 C 语言可以写出多重赋值表达式。
    >
    > ```
    > int x, y, z, m, n;
    > 
    > x = y = z = m = n = 3;
    > ```
    >
    > 上面的代码是合法代码，一次为多个变量赋值。赋值运算符是从右到左执行，所以先为`n`赋值，然后依次为`m`、`z`、`y`和`x`赋值。
    >
    > C 语言有左值（left value）和右值（right value）的概念。左值是可以放在赋值运算符左边的值，一般是变量；右值是可以放在赋值运算符右边的值，一般是一个具体的值。这是为了强调有些值不能放在赋值运算符的左边，比如`x = 1`是合法的表达式，但是`1 = x`就会报错。

  - #### 变量的作用域

    > 作用域（scope）指的是变量生效的范围。C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。
    >
    > 文件作用域（file scope）指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。
    >
    > ```
    > int x = 1;
    > 
    > int main(void) {
    >   printf("%i\n", x);
    > }
    > ```
    >
    > 上面示例中，变量`x`是在文件顶层声明的，从声明位置开始的整个当前文件都是它的作用域，可以在这个范围的任何地方读取这个变量，比如函数`main()`内部就可以读取这个变量。
    >
    > 块作用域（block scope）指的是由大括号（`{}`）组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。
    >
    > ```
    > int a = 12;
    > 
    > if (a == 12) {
    >   int b = 99;
    >   printf("%d %d\n", a, b);  // 12 99
    > }
    > 
    > printf("%d\n", a);  // 12
    > printf("%d\n", b);  // 出错
    > ```
    >
    > 上面例子中，变量`b`是在`if`代码块里面声明的，所以对于大括号外面的代码，这个变量是不存在的。
    >
    > 代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。
    >
    > ```
    > {
    >   int i = 10;
    > 
    >   {
    >     int i = 20;
    >     printf("%d\n", i);  // 20
    >   }
    > 
    >   printf("%d\n", i);  // 10
    > }
    > ```
    >
    > 上面示例中，内层和外层都有一个变量`i`，每个作用域都会优先使用当前作用域声明的`i`。
    >
    > 最常见的块作用域就是函数，函数内部声明的变量，对于函数外部是不可见的。`for`循环也是一个块作用域，循环变量只对循环体内部可见，外部是不可见的。
    >
    > ```
    > for (int i = 0; i < 10; i++)
    >   printf("%d\n", i);
    > 
    > printf("%d\n", i); // 出错
    > ```
    >
    > 上面示例中，`for`循环省略了大括号，但依然是一个块作用域，在外部读取循环变量`i`，编译器就会报错。

- ## 运算符

  > C 语言的运算符非常多，一共有 50 多种，可以分成若干类。

  - #### 算术运算符

    > 算术运算符专门用于算术运算，主要有下面几种。
    >
    > - `+`：正值运算符（一元运算符）
    > - `-`：负值运算符（一元运算符）
    > - `+`：加法运算符（二元运算符）
    > - `-`：减法运算符（二元运算符）
    > - `*`：乘法运算符
    > - `/`：除法运算符
    > - `%`：余值运算符
    >
    > （1）`+`，`-`
    >
    > `+`和`-`既可以作为一元运算符，也可以作为二元运算符。所谓“一元运算符”，指的是只需要一个运算数就可以执行。一元运算符`-`用来改变一个值的正负号。
    >
    > ```
    > int x = -12;
    > ```
    >
    > 上面示例中，`-`将`12`这个值变成`-12`。
    >
    > 一元运算符`+`对正负值没有影响，是一个完全可以省略的运算符，但是写了也不会报错。
    >
    > ```
    > int x = -12;
    > int y = +x;
    > ```
    >
    > 上面示例中，变量`y`的值还是`-12`，因为`+`不会改变正负值。
    >
    > 二元运算符`+`和`-`用来完成加法和减法。
    >
    > ```
    > int x = 4 + 22;
    > int y = 61 - 23;
    > ```
    >
    > （2）`*`
    >
    > 运算符`*`用来完成乘法。
    >
    > ```
    > int num = 5;
    > printf("%i\n", num * num); // 输出 25
    > ```
    >
    > （3）`/`
    >
    > 运算符`/`用来完成除法。注意，两个整数相除，得到还是一个整数。
    >
    > ```
    > float x = 6 / 4;
    > printf("%f\n", x); // 输出 1.000000
    > ```
    >
    > 上面示例中，尽管变量`x`的类型是`float`（浮点数），但是`6 / 4`得到的结果是`1.0`，而不是`1.5`。原因就在于 C 语言里面的整数除法是整除，只会返回整数部分，丢弃小数部分。
    >
    > 如果希望得到浮点数的结果，两个运算数必须至少有一个浮点数，这时 C 语言就会进行浮点数除法。
    >
    > ```
    > float x = 6.0 / 4; // 或者写成 6 / 4.0
    > printf("%f\n", x); // 输出 1.500000
    > ```
    >
    > 上面示例中，`6.0 / 4`表示进行浮点数除法，得到的结果就是`1.5`。
    >
    > 下面是另一个例子。
    >
    > ```
    > int score = 5;
    > score = (score / 20) * 100;
    > ```
    >
    > 上面的代码，你可能觉得经过运算，`score`会等于`25`，但是实际上`score`等于`0`。这是因为`score / 20`是整除，会得到一个整数值`0`，所以乘以`100`后得到的也是`0`。
    >
    > 为了得到预想的结果，可以将除数`20`改成`20.0`，让整除变成浮点数除法。
    >
    > ```
    > score = (score / 20.0) * 100;
    > ```
    >
    > （4）`%`
    >
    > 运算符`%`表示求模运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数。
    >
    > ```
    > int x = 6 % 4; // 2
    > ```
    >
    > 负数求模的规则是，结果的正负号由第一个运算数的正负号决定。
    >
    > ```
    > 11 % -5 // 1
    > -11 % -5 // -1
    > -11 % 5 // -1
    > ```
    >
    > 上面示例中，第一个运算数的正负号（`11`或`-11`）决定了结果的正负号。
    >
    > （5）赋值运算的简写形式
    >
    > 如果变量对自身的值进行算术运算，C 语言提供了简写形式，允许将赋值运算符和算术运算符结合成一个运算符。
    >
    > - `+=`
    > - `-=`
    > - `*=`
    > - `/=`
    > - `%=`
    >
    > 下面是一些例子。
    >
    > ```
    > i += 3;  // 等同于 i = i + 3
    > i -= 8;  // 等同于 i = i - 8
    > i *= 9;  // 等同于 i = i * 9
    > i /= 2;  // 等同于 i = i / 2
    > i %= 5;  // 等同于 i = i % 5
    > ```

  - #### 自增运算符，自减运算符

    > C 语言提供两个运算符，对变量自身进行`+ 1`和`- 1`的操作。
    >
    > - `++`：自增运算符
    > - `--`：自减运算符
    >
    > ```
    > i++; // 等同于 i = i + 1
    > i--; // 等同于 i = i - 1
    > ```
    >
    > 这两个运算符放在变量的前面或后面，结果是不一样的。`++var`和`--var`是先执行自增或自减操作，再返回操作后`var`的值；`var++`和`var--`则是先返回操作前`var`的值，再执行自增或自减操作。
    >
    > ```
    > int i = 42;
    > int j;
    > 
    > j = (i++ + 10);
    > // i: 43
    > // j: 52
    > 
    > j = (++i + 10)
    > // i: 44
    > // j: 54
    > ```
    >
    > 上面示例中，自增运算符的位置差异，会导致变量`j`得到不同的值。这样的写法很容易出现意料之外的结果，为了消除意外，可以改用下面的写法。
    >
    > ```
    > /* 写法一 */
    > j = (i + 10);
    > i++;
    > 
    > /* 写法二 */
    > i++;
    > j = (i + 10);
    > ```
    >
    > 上面示例中，变量`i`的自增运算与返回值是分离的两个步骤，这样就不太会出错，也提高了代码的可读性。

  - #### 关系运算符

    > C 语言用于比较的表达式，称为“关系表达式”（relational expression），里面使用的运算符就称为“关系运算符”（relational operator），主要有下面6个。
    >
    > - `>` 大于运算符
    > - `<` 小于运算符
    > - `>=` 大于等于运算符
    > - `<=` 小于等于运算符
    > - `==` 相等运算符
    > - `!=` 不相等运算符
    >
    > 下面是一些例子。
    >
    > ```
    > a == b;
    > a != b;
    > a < b;
    > a > b;
    > a <= b;
    > a >= b;
    > ```
    >
    > 关系表达式通常返回`0`或`1`，表示真伪。C 语言中，`0`表示伪，所有非零值表示真。比如，`20 > 12`返回`1`，`12 > 20`返回`0`。
    >
    > 关系表达式常用于`if`或`while`结构。
    >
    > ```
    > if (x == 3) {
    >   printf("x is 3.\n");
    > }
    > ```
    >
    > 注意，相等运算符`==`与赋值运算符`=`是两个不一样的运算符，不要混淆。有时候，可能会不小心写出下面的代码，它可以运行，但很容易出现意料之外的结果。
    >
    > ```
    > if (x = 3) ...
    > ```
    >
    > 上面示例中，原意是`x == 3`，但是不小心写成`x = 3`。这个式子表示对变量`x`赋值`3`，它的返回值为`3`，所以`if`判断总是为真。
    >
    > 为了防止出现这种错误，有的程序员喜欢将变量写在等号的右边。
    >
    > ```
    > if (3 == x) ...
    > ```
    >
    > 这样的话，如果把`==`误写成`=`，编译器就会报错。
    >
    > ```
    > /* 报错 */
    > if (3 = x) ...
    > ```
    >
    > 另一个需要避免的错误是，多个关系运算符不宜连用。
    >
    > ```
    > i < j < k
    > ```
    >
    > 上面示例中，连续使用两个小于运算符。这是合法表达式，不会报错，但是通常达不到想要的结果，即不是保证变量`j`的值在`i`和`k`之间。因为关系运算符是从左到右计算，所以实际执行的是下面的表达式。
    >
    > ```
    > (i < j) < k
    > ```
    >
    > 上面式子中，`i < j`返回`0`或`1`，所以最终是`0`或`1`与变量`k`进行比较。如果想要判断变量`j`的值是否在`i`和`k`之间，应该使用下面的写法。
    >
    > ```
    > i < j && j < k
    > ```

  - #### 逻辑运算符

    > 逻辑运算符提供逻辑判断功能，用于构建更复杂的表达式，主要有下面三个运算符。
    >
    > - `!`：否运算符（改变单个表达式的真伪）。
    > - `&&`：与运算符（两侧的表达式都为真，则为真，否则为伪）。
    > - `||`：或运算符（两侧至少有一个表达式为真，则为真，否则为伪）。
    >
    > 下面是与运算符的例子。
    >
    > ```
    > if (x < 10 && y > 20)
    >   printf("Doing something!\n");
    > ```
    >
    > 上面示例中，只有`x < 10`和`y > 20`同时为真，`x < 10 && y > 20`才会为真。
    >
    > 下面是否运算符的例子。
    >
    > ```
    > if (!(x < 12))
    >   printf("x is not less than 12\n");
    > ```
    >
    > 上面示例中，由于否运算符`!`具有比`<`更高的优先级，所以必须使用括号，才能对表达式`x < 12`进行否运算。当然，合理的写法是`if (x >= 12)`，这里只是为了举例。
    >
    > 对于逻辑运算符来说，任何非零值都表示真，零值表示伪。比如，`5 || 0`会返回`1`，`5 && 0`会返回`0`。
    >
    > 逻辑运算符还有一个特点，它总是先对左侧的表达式求值，再对右边的表达式求值，这个顺序是保证的。如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值。这种情况称为“短路”。
    >
    > ```
    > if (number != 0 && 12/number == 2)
    > ```
    >
    > 上面示例中，如果`&&`左侧的表达式（`number != 0`）为伪，即`number`等于`0`时，右侧的表达式（`12/number == 2`）是不会执行的。因为这时左侧表达式返回`0`，整个`&&`表达式肯定为伪，就直接返回`0`，不再执行右侧的表达式了。
    >
    > 由于逻辑运算符的执行顺序是先左后右，所以下面的代码是有问题的。
    >
    > ```
    > while ((x++ < 10) && (x + y < 20))
    > ```
    >
    > 上面示例中，执行左侧表达式后，变量`x`的值就已经变了。等到执行右侧表达式的时候，是用新的值在计算，这通常不是原始意图。

  - #### 位运算符

    > C 语言提供一些位运算符，用来操作二进制位（bit）。
    >
    > （1）取反运算符`～`
    >
    > 取反运算符`～`是一个一元运算符，用来将每一个二进制位变成相反值，即`0`变成`1`，`1`变成`0`。
    >
    > ```
    > // 返回 01101100
    > ~ 10010011
    > ```
    >
    > 上面示例中，`~`对每个二进制位取反，就得到了一个新的值。
    >
    > 注意，`~`运算符不会改变变量的值，只是返回一个新的值。
    >
    > （2）与运算符`&`
    >
    > 与运算符`&`将两个值的每一个二进制位进行比较，返回一个新的值。当两个二进制位都为`1`，就返回`1`，否则返回`0`。
    >
    > ```
    > // 返回 00010001
    > 10010011 & 00111101
    > ```
    >
    > 上面示例中，两个八位二进制数进行逐位比较，返回一个新的值。
    >
    > 与运算符`&`可以与赋值运算符`=`结合，简写成`&=`。
    >
    > ```
    > int val = 3;
    > val = val & 0377;
    > 
    > // 简写成
    > val &= 0377;
    > ```
    >
    > （3）或运算符`|`
    >
    > 或运算符`|`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位只要有一个为`1`（包含两个都为`1`的情况），就返回`1`，否则返回`0`。
    >
    > ```
    > // 返回 10111111
    > 10010011 | 00111101
    > ```
    >
    > 或运算符`|`可以与赋值运算符`=`结合，简写成`|=`。
    >
    > ```
    > int val = 3;
    > val = val | 0377;
    > 
    > // 简写为
    > val |= 0377;
    > ```
    >
    > （4）异或运算符`^`
    >
    > 异或运算符`^`将两个值的每一个二进制位进行比较，返回一个新的值。两个二进制位有且仅有一个为`1`，就返回`1`，否则返回`0`。
    >
    > ```
    > // 返回 10101110
    > 10010011 ^ 00111101
    > ```
    >
    > 异或运算符`^`可以与赋值运算符`=`结合，简写成`^=`。
    >
    > ```
    > int val = 3;
    > val = val ^ 0377;
    > 
    > // 简写为
    > val ^= 0377;
    > ```
    >
    > （5）左移运算符`<<`
    >
    > 左移运算符`<<`将左侧运算数的每一位，向左移动指定的位数，尾部空出来的位置使用`0`填充。
    >
    > ```
    > // 1000101000
    > 10001010 << 2
    > ```
    >
    > 上面示例中，`10001010`的每一个二进制位，都向左侧移动了两位。
    >
    > 左移运算符相当于将运算数乘以2的指定次方，比如左移2位相当于乘以4（2的2次方）。
    >
    > 左移运算符`<<`可以与赋值运算符`=`结合，简写成`<<=`。
    >
    > ```
    > int val = 1;
    > val = val << 2;
    > 
    > // 简写为
    > val <<= 2;
    > ```
    >
    > （6）右移运算符`>>`
    >
    > 右移运算符`>>`将左侧运算数的每一位，向右移动指定的位数，尾部无法容纳的值将丢弃，头部空出来的位置使用`0`填充。
    >
    > ```
    > // 返回 00100010
    > 10001010 >> 2
    > ```
    >
    > 上面示例中，`10001010`的每一个二进制位，都向右移动两位。最低的两位`10`被丢弃，头部多出来的两位补`0`，所以最后得到`00100010`。
    >
    > 注意，右移运算符最好只用于无符号整数，不要用于负数。因为不同系统对于右移后如何处理负数的符号位，有不同的做法，可能会得到不一样的结果。
    >
    > 右移运算符相当于将运算数除以2的指定次方，比如右移2位就相当于除以4（2的2次方）。
    >
    > 右移运算符`>>`可以与赋值运算符`=`结合，简写成`>>=`。
    >
    > ```
    > int val = 1;
    > val = val >> 2;
    > 
    > // 简写为
    > val >>= 2;
    > ```

  - #### 逗号运算符

    > 逗号运算符用于将多个表达式写在一起，从左到右依次运行每个表达式。
    >
    > ```
    > x = 10, y = 20;
    > ```
    >
    > 上面示例中，有两个表达式（`x = 10`和`y = 20`），逗号使得它们可以放在同一条语句里面。
    >
    > 逗号运算符返回最后一个表达式的值，作为整个语句的值。
    >
    > ```
    > int x;
    > 
    > x = (1, 2, 3);
    > ```
    >
    > 上面示例中，括号里面的逗号运算符，返回最后一个表达式的值，所以变量`x`等于`3`。

  - #### 运算优先级

    > 优先级指的是，如果一个表达式包含多个运算符，哪个运算符应该优先执行。各种运算符的优先级是不一样的。
    >
    > ```
    > 3 + 4 * 5;
    > ```
    >
    > 上面示例中，表达式`3 + 4 * 5`里面既有加法运算符（`+`），又有乘法运算符（`*`）。由于乘法的优先级高于加法，所以会先计算`4 * 5`，而不是先计算`3 + 4`。
    >
    > 如果两个运算符优先级相同，则根据运算符是左结合，还是右结合，决定执行顺序。大部分运算符是左结合（从左到右执行），少数运算符是右结合（从右到左执行），比如赋值运算符（`=`）。
    >
    > ```
    > 5 * 6 / 2;
    > ```
    >
    > 上面示例中，`*`和`/`的优先级相同，它们都是左结合运算符，所以从左到右执行，先计算`5 * 6`，再计算`30 / 2`。
    >
    > 运算符的优先级顺序很复杂。下面是部分运算符的优先级顺序（按照优先级从高到低排列）。
    >
    > - 圆括号（`()`）
    > - 自增运算符（`++`），自减运算符（`--`）
    > - 一元运算符（`+`和`-`）
    > - 乘法（`*`），除法（`/`）
    > - 加法（`+`），减法（`-`）
    > - 关系运算符（`<`、`>`等）
    > - 赋值运算符（`=`）
    >
    > 由于圆括号的优先级最高，可以使用它改变其他运算符的优先级。
    >
    > ```
    > int x = (3 + 4) * 5;
    > ```
    >
    > 上面示例中，由于添加了圆括号，加法会先于乘法进行运算。
    >
    > 完全记住所有运算符的优先级没有必要，解决方法是多用圆括号，防止出现意料之外的情况，也有利于提高代码的可读性。


------

